package ch.epfl.labos.iu.orm.trace;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

public class LoggedStatement implements Statement
{
   Statement wrapped;
   public LoggedStatement(Statement wrapped)
   {
      this.wrapped = wrapped;
   }
   
   public ResultSet executeQuery(String sql) throws SQLException
   {
      System.out.println("Statement.executeQuery: " + sql);
      return wrapped.executeQuery(sql);
   }

   public int executeUpdate(String sql) throws SQLException
   {
      System.out.println("Statement.executeUpdate: " + sql);
      return wrapped.executeUpdate(sql);
   }

   public void close() throws SQLException
   {
      wrapped.close();
   }

   public int getMaxFieldSize() throws SQLException
   {
      return wrapped.getMaxFieldSize();
   }

   public void setMaxFieldSize(int max) throws SQLException
   {
      wrapped.setMaxFieldSize(max);
   }

   public int getMaxRows() throws SQLException
   {
      return wrapped.getMaxRows();
   }

   public void setMaxRows(int max) throws SQLException
   {
      wrapped. setMaxRows(max);
   }

   public void setEscapeProcessing(boolean enable) throws SQLException
   {
      wrapped.setEscapeProcessing(enable);
   }

   public int getQueryTimeout() throws SQLException
   {
      return wrapped.getQueryTimeout();
   }

   public void setQueryTimeout(int seconds) throws SQLException
   {
      wrapped.setQueryTimeout(seconds);
   }

   public void cancel() throws SQLException
   {
      wrapped.cancel();
   }

   public SQLWarning getWarnings() throws SQLException
   {
      return wrapped.getWarnings();
   }

   public void clearWarnings() throws SQLException
   {
      wrapped.clearWarnings();
   }

   public void setCursorName(String name) throws SQLException
   {
      wrapped.setCursorName(name);
   }

   public boolean execute(String sql) throws SQLException
   {
      System.out.println("Statement.execute: " + sql);
      return wrapped.execute(sql);
   }

   public ResultSet getResultSet() throws SQLException
   {
      return wrapped.getResultSet();
   }

   public int getUpdateCount() throws SQLException
   {
      return wrapped.getUpdateCount();
   }

   public boolean getMoreResults() throws SQLException
   {
      return wrapped.getMoreResults() ;
   }

   public void setFetchDirection(int direction) throws SQLException
   {
      wrapped.setFetchDirection(direction);
   }

   public int getFetchDirection() throws SQLException
   {
      return wrapped.getFetchDirection();
   }

   public void setFetchSize(int rows) throws SQLException
   {
      wrapped.setFetchSize(rows);
   }

   public int getFetchSize() throws SQLException
   {
      return wrapped.getFetchSize();
   }

   public int getResultSetConcurrency() throws SQLException
   {
      return wrapped.getResultSetConcurrency();
   }

   public int getResultSetType() throws SQLException
   {
      return wrapped.getResultSetType();
   }

   public void addBatch(String sql) throws SQLException
   {
      wrapped.addBatch(sql);
   }

   public void clearBatch() throws SQLException
   {
      wrapped.clearBatch();
   }

   public int[] executeBatch() throws SQLException
   {
      return wrapped.executeBatch();
   }

   public Connection getConnection() throws SQLException
   {
      return wrapped.getConnection();
   }

   public boolean getMoreResults(int current) throws SQLException
   {
      return wrapped.getMoreResults(current);
   }

   public ResultSet getGeneratedKeys() throws SQLException
   {
      return wrapped.getGeneratedKeys();
   }

   public int executeUpdate(String sql, int autoGeneratedKeys)
         throws SQLException
   {
      System.out.println("Statement.executeUpdate: " + sql);
      return wrapped.executeUpdate(sql, autoGeneratedKeys);
   }

   public int executeUpdate(String sql, int[] columnIndexes)
         throws SQLException
   {
      System.out.println("Statement.executeUpdate: " + sql);
      return wrapped.executeUpdate(sql, columnIndexes);
   }

   public int executeUpdate(String sql, String[] columnNames)
         throws SQLException
   {
      System.out.println("Statement.executeUpdate: " + sql);
      return wrapped.executeUpdate(sql,  columnNames);
   }

   public boolean execute(String sql, int autoGeneratedKeys)
         throws SQLException
   {
      System.out.println("Statement.execute: " + sql);
      return wrapped.execute(sql, autoGeneratedKeys);
   }

   public boolean execute(String sql, int[] columnIndexes) throws SQLException
   {
      System.out.println("Statement.execute: " + sql);
      return wrapped.execute(sql, columnIndexes);
   }

   public boolean execute(String sql, String[] columnNames) throws SQLException
   {
      System.out.println("Statement.execute: " + sql);
      return wrapped.execute(sql, columnNames);
   }

   public int getResultSetHoldability() throws SQLException
   {
      return wrapped.getResultSetHoldability();
   }

  @Override
  public boolean isWrapperFor(Class<?> arg0) throws SQLException
  {
    return wrapped.isWrapperFor(arg0);
  }

  @Override
  public <T> T unwrap(Class<T> arg0) throws SQLException
  {
    return wrapped.unwrap(arg0);
  }

  @Override
  public void closeOnCompletion() throws SQLException
  {
    wrapped.closeOnCompletion();
  }

  @Override
  public boolean isCloseOnCompletion() throws SQLException
  {
    return wrapped.isCloseOnCompletion();
  }

  @Override
  public boolean isClosed() throws SQLException
  {
    return wrapped.isClosed();
  }

  @Override
  public boolean isPoolable() throws SQLException
  {
    return wrapped.isPoolable();
  }

  @Override
  public void setPoolable(boolean arg0) throws SQLException
  {
    wrapped.setPoolable(arg0);
  }

}
